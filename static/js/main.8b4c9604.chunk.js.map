{"version":3,"sources":["Canvas.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Canvas","props","canvasRef","useRef","draw","useEffect","canvas","current","context","getContext","frameCount","animationFrameId","render","window","requestAnimationFrame","cancelAnimationFrame","ref","NODE_SIZE","FACTIONS","getFactionColor","faction","App","nodes","x","y","power","connections","i","length","j","con","n1","n2","alreadyExists","existingCon","push","generateLevel","initialNodes","initialConnections","nodesRef","connectionsRef","travelingPower","selectedNode","useState","isPaused","setIsPaused","none","totalPower","controlledNodes","player","red","stats","setStats","clicked","mouseX","mouseY","previousSelectedNode","findClickedNode","previousNode","foundOtherNode","startNode","endNode","t","update","newStats","node","travel","queue","parents","Map","goals","visited","Set","cur","prev","cost","set","parent","element","pop","undefined","has","get","add","goal","sort","a","b","g","neighbors","neighbor","currentNode","doAI","arrivedPower","tPower","Math","abs","splice","updateTravelingPower","style","borderStyle","borderWidth","borderColor","width","height","onClick","event","clientX","clientY","ctx","clearRect","node1","node2","beginPath","moveTo","lineTo","stroke","textAlign","textBaseline","nStart","nEnd","fillStyle","arc","PI","fill","fillText","toFixed","fillRect","size","display","gridTemplateColumns","map","f","s","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8b4c9604.chunk.js","sourcesContent":["import { useRef, useEffect } from \"react\";\n\nexport default function Canvas(\n  props: {\n    draw: (ctx: CanvasRenderingContext2D, frameCount: number) => void;\n  } & React.CanvasHTMLAttributes<HTMLCanvasElement>\n) {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const { draw } = props;\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas === null) {\n      return;\n    }\n    const context = canvas.getContext(\"2d\");\n    if (context === null) {\n      return;\n    }\n    let frameCount = 0;\n    let animationFrameId = 0;\n\n    const render = () => {\n      frameCount++;\n      draw(context, frameCount);\n      animationFrameId = window.requestAnimationFrame(render);\n    };\n    render();\n\n    return () => {\n      window.cancelAnimationFrame(animationFrameId);\n    };\n  }, [draw]);\n\n  return <canvas ref={canvasRef} {...props} />;\n}\n","import React, { useRef, useState } from \"react\";\nimport \"./App.css\";\nimport Canvas from \"./Canvas\";\n\nconst NODE_SIZE = 20;\nconst POWER_SPEED = 0.0075;\n\nconst FACTIONS = [\"none\", \"red\", \"player\"] as const;\ntype FactionTuple = typeof FACTIONS;\ntype Faction = FactionTuple[number];\n\ntype Node = {\n  x: number;\n  y: number;\n  power: number;\n  faction: Faction;\n  connections: number[];\n};\n\ntype Connection = {\n  n1: number;\n  n2: number;\n};\n\ntype TravelPower = {\n  startNode: number;\n  endNode: number;\n  power: number;\n  faction: Faction;\n  t: number;\n};\n\ntype FactionStatistics = {\n  totalPower: number;\n  controlledNodes: number;\n};\ntype Statistics = { [key in Faction]: FactionStatistics };\n\nfunction getFactionColor(faction: Faction): string {\n  switch (faction) {\n    case null:\n      return \"#aaaaaa\";\n    case \"red\":\n      return \"#ff0000\";\n    case \"player\":\n      return \"#00ff00\";\n  }\n  return \"#aaaaaa\";\n}\n\nfunction generateLevel(): [Node[], Connection[]] {\n  const nodes = [\n    {\n      x: 100,\n      y: 100,\n      faction: \"player\" as Faction,\n      power: 3,\n      connections: [1, 3],\n    },\n    {\n      x: 250,\n      y: 50,\n      faction: \"none\" as Faction,\n      power: 3,\n      connections: [0, 2, 3],\n    },\n    {\n      x: 400,\n      y: 100,\n      faction: \"none\" as Faction,\n      power: 3,\n      connections: [1, 3],\n    },\n    {\n      x: 250,\n      y: 150,\n      faction: \"none\" as Faction,\n      power: 3,\n      connections: [0, 1, 2, 4, 6],\n    },\n\n    {\n      x: 100,\n      y: 250,\n      faction: \"none\" as Faction,\n      power: 3,\n      connections: [3, 5],\n    },\n    {\n      x: 250,\n      y: 300,\n      faction: \"red\" as Faction,\n      power: 3,\n      connections: [4, 6],\n    },\n    {\n      x: 400,\n      y: 250,\n      faction: \"none\" as Faction,\n      power: 3,\n      connections: [3, 5],\n    },\n  ];\n\n  const connections = [];\n  for (let i = 0; i < nodes.length; i++) {\n    for (let j = 0; j < nodes[i].connections.length; j++) {\n      const con = { n1: i, n2: nodes[i].connections[j] };\n      let alreadyExists = false;\n      for (const existingCon of connections) {\n        if (\n          (con.n1 === existingCon.n1 && con.n2 === existingCon.n2) ||\n          (con.n1 === existingCon.n2 && con.n2 === existingCon.n1)\n        ) {\n          alreadyExists = true;\n          break;\n        }\n      }\n      if (!alreadyExists) {\n        connections.push(con);\n      }\n    }\n  }\n\n  return [nodes, connections];\n}\n\nfunction App() {\n  const [initialNodes, initialConnections] = generateLevel();\n\n  const nodesRef = useRef<Node[]>(initialNodes);\n  const connectionsRef = useRef<Connection[]>(initialConnections);\n  const travelingPower = useRef<TravelPower[]>([]);\n  const selectedNode = useRef<number | null>(null);\n\n  const [isPaused, setIsPaused] = useState<boolean>(false);\n  const [stats, setStats] = useState<Statistics>({\n    none: { totalPower: 3, controlledNodes: 1 },\n    player: { totalPower: 3, controlledNodes: 1 },\n    red: { totalPower: 3, controlledNodes: 1 },\n  });\n\n  const findClickedNode = (mouseX: number, mouseY: number): number | null => {\n    const sHalf = NODE_SIZE / 2;\n    for (let i = 0; i < nodesRef.current.length; i++) {\n      const { x, y } = nodesRef.current[i];\n      if (\n        x - sHalf < mouseX &&\n        x + sHalf > mouseX &&\n        y - sHalf < mouseY &&\n        y + sHalf > mouseY\n      ) {\n        return i;\n      }\n    }\n    return null;\n  };\n\n  const clicked = (mouseX: number, mouseY: number) => {\n    const previousSelectedNode = selectedNode.current;\n    selectedNode.current = findClickedNode(mouseX, mouseY);\n    if (selectedNode.current === null || previousSelectedNode === null) {\n      return;\n    }\n\n    const previousNode = nodesRef.current[previousSelectedNode];\n    if (previousNode.faction !== \"player\") {\n      return;\n    }\n\n    let foundOtherNode = false;\n    for (const con of previousNode.connections) {\n      if (selectedNode.current === con) {\n        foundOtherNode = true;\n        break;\n      }\n    }\n    if (!foundOtherNode) {\n      return;\n    }\n\n    travelingPower.current.push({\n      startNode: previousSelectedNode,\n      endNode: selectedNode.current,\n      power: previousNode.power,\n      faction: previousNode.faction,\n      t: 0.0,\n    });\n    previousNode.power = 0;\n    selectedNode.current = null;\n  };\n\n  const updateTravelingPower = () => {\n    const arrivedPower = [];\n    for (let i = 0; i < travelingPower.current.length; i++) {\n      const tPower = travelingPower.current[i];\n      tPower.t += POWER_SPEED;\n      if (tPower.t >= 1.0) {\n        arrivedPower.push(i);\n      }\n    }\n\n    for (const i of arrivedPower.sort((a, b) => b - a)) {\n      const tPower = travelingPower.current[i];\n      const endNode = nodesRef.current[tPower.endNode];\n      if (endNode.faction === tPower.faction) {\n        endNode.power += tPower.power;\n      } else {\n        endNode.power -= tPower.power;\n        if (endNode.power <= 0) {\n          endNode.power = Math.abs(endNode.power);\n          endNode.faction = tPower.faction;\n        }\n      }\n      travelingPower.current.splice(i, 1);\n    }\n  };\n\n  const doAI = () => {\n    for (let i = 0; i < nodesRef.current.length; i++) {\n      if (\n        nodesRef.current[i].faction === \"none\" ||\n        nodesRef.current[i].faction === \"player\"\n      ) {\n        continue;\n      }\n\n      const queue: { cur: number; prev: number; cost: number }[] = [];\n      const parents = new Map<number, { parent: number; cost: number }>();\n      const goals: { goal: number; cost: number }[] = [];\n      const visited = new Set<number>();\n\n      for (const con of nodesRef.current[i].connections) {\n        queue.push({ cur: con, prev: i, cost: 1 });\n        parents.set(i, { parent: -1, cost: 0 });\n      }\n\n      while (queue.length > 0) {\n        const element = queue.pop();\n        if (element === undefined) {\n          break;\n        }\n\n        const { cur, prev, cost } = element;\n        if (visited.has(cur)) {\n          const parent = parents.get(cur);\n          if (parent === undefined) {\n            parents.set(cur, { parent: prev, cost: cost });\n          } else if (parent.cost > cost) {\n            parents.set(cur, { parent: prev, cost: cost });\n          } else {\n            continue;\n          }\n\n          for (const con of nodesRef.current[cur].connections) {\n            queue.push({ cur: con, prev: cur, cost: cost + 1 });\n          }\n\n          continue;\n        }\n\n        visited.add(cur);\n\n        if (nodesRef.current[cur].faction === \"red\") {\n          for (const con of nodesRef.current[cur].connections) {\n            queue.push({ cur: con, prev: cur, cost: cost + 1 });\n          }\n        } else {\n          goals.push({ goal: cur, cost });\n        }\n      }\n\n      goals.sort((a, b) => a.cost - b.cost);\n      if (goals.length === 0) {\n        continue;\n      }\n\n      const g = goals[0];\n      if (g === undefined) {\n        continue;\n      }\n      const { goal } = g;\n\n      const neighbors = new Set<number>();\n      for (const neighbor of nodesRef.current[i].connections) {\n        neighbors.add(neighbor);\n      }\n\n      if (neighbors.has(goal)) {\n        if (\n          (nodesRef.current[goal].faction === \"red\" &&\n            nodesRef.current[i].power > 0) ||\n          nodesRef.current[i].power > nodesRef.current[goal].power\n        ) {\n          travelingPower.current.push({\n            startNode: i,\n            endNode: goal,\n            power: nodesRef.current[i].power,\n            faction: nodesRef.current[i].faction,\n            t: 0.0,\n          });\n          nodesRef.current[i].power = 0;\n        }\n      } else {\n        let currentNode = goal;\n        while (true) {\n          if (neighbors.has(currentNode)) {\n            if (\n              (nodesRef.current[currentNode].faction === \"red\" &&\n                nodesRef.current[i].power > 0) ||\n              nodesRef.current[i].power > nodesRef.current[currentNode].power\n            ) {\n              travelingPower.current.push({\n                startNode: i,\n                endNode: currentNode,\n                power: nodesRef.current[i].power,\n                faction: nodesRef.current[i].faction,\n                t: 0.0,\n              });\n              nodesRef.current[i].power = 0;\n            }\n            break;\n          }\n          const parent = parents.get(currentNode);\n          if (parent === undefined) {\n            break;\n          }\n          currentNode = parent.parent;\n        }\n      }\n    }\n  };\n\n  const update = (frameCount: number) => {\n    if (frameCount % 60 === 0) {\n      const newStats: Statistics = {\n        none: { totalPower: 0, controlledNodes: 0 },\n        red: { totalPower: 0, controlledNodes: 0 },\n        player: { totalPower: 0, controlledNodes: 0 },\n      };\n      for (const node of nodesRef.current) {\n        newStats[node.faction].controlledNodes++;\n        newStats[node.faction].totalPower += node.power;\n      }\n      for (const travel of travelingPower.current) {\n        newStats[travel.faction].totalPower += travel.power;\n      }\n      setStats(newStats);\n    }\n\n    if (frameCount % 50 === 0) {\n      for (let i = 0; i < nodesRef.current.length; i++) {\n        if (nodesRef.current[i].faction === \"none\") {\n          continue;\n        }\n        nodesRef.current[i].power++;\n      }\n    }\n\n    doAI();\n    updateTravelingPower();\n  };\n\n  const render = (ctx: CanvasRenderingContext2D) => {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    for (const { n1, n2 } of connectionsRef.current) {\n      const node1 = nodesRef.current[n1];\n      const node2 = nodesRef.current[n2];\n      ctx.beginPath();\n      ctx.moveTo(node1.x, node1.y);\n      ctx.lineTo(node2.x, node2.y);\n      ctx.stroke();\n    }\n\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n\n    for (let i = 0; i < travelingPower.current.length; i++) {\n      const { startNode, endNode, power, faction, t } = travelingPower.current[\n        i\n      ];\n      const nStart = nodesRef.current[startNode];\n      const nEnd = nodesRef.current[endNode];\n      const x = nStart.x * (1 - t) + nEnd.x * t;\n      const y = nStart.y * (1 - t) + nEnd.y * t;\n\n      ctx.fillStyle = getFactionColor(faction);\n      ctx.beginPath();\n      ctx.arc(x, y, NODE_SIZE / 2, 0, 2 * Math.PI);\n      ctx.fill();\n\n      ctx.fillStyle = \"#000000\";\n      ctx.fillText(power.toFixed(0), x, y);\n    }\n\n    for (let i = 0; i < nodesRef.current.length; i++) {\n      const { x, y, power, faction } = nodesRef.current[i];\n\n      if (selectedNode.current === i) {\n        ctx.fillStyle = \"#000000\";\n        const size = NODE_SIZE * 1.1;\n        ctx.fillRect(x - size / 2, y - size / 2, size, size);\n      }\n\n      ctx.fillStyle = getFactionColor(faction);\n      ctx.fillRect(x - NODE_SIZE / 2, y - NODE_SIZE / 2, NODE_SIZE, NODE_SIZE);\n\n      ctx.fillStyle = \"#000000\";\n      ctx.fillText(power.toFixed(0), x, y);\n      ctx.fillText(i.toFixed(0), x + 15, y);\n    }\n  };\n\n  const draw = (ctx: CanvasRenderingContext2D, frameCount: number) => {\n    if (isPaused) {\n      return;\n    }\n\n    update(frameCount);\n    render(ctx);\n  };\n\n  return (\n    <div\n      style={{\n        borderStyle: \"solid\",\n        borderWidth: \"1px\",\n        borderColor: \"black\",\n        width: \"500px\",\n        height: \"500px\",\n      }}\n    >\n      <Canvas\n        width=\"500px\"\n        height=\"500px\"\n        onClick={(event) => {\n          const mouseX = event.clientX;\n          const mouseY = event.clientY;\n          clicked(mouseX, mouseY);\n        }}\n        draw={draw}\n      />\n      <button onClick={() => setIsPaused(!isPaused)}>\n        {isPaused ? \"Resume\" : \"Pause\"}\n      </button>\n      <div style={{ display: \"grid\", gridTemplateColumns: \"1fr 1fr 1fr\" }}>\n        <div>Faction</div>\n        <div>Total Power</div>\n        <div>Controlled Nodes</div>\n        {FACTIONS.map((f: Faction) => {\n          const s = stats[f];\n          return (\n            <>\n              <div>{f}</div>\n              <div>{s.totalPower}</div>\n              <div>{s.controlledNodes}</div>\n            </>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}